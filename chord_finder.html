<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Chord finder</title>
  </head>
  <body>
    <h2>Chord finder</h2>
    <!-- settings -->
    <div class="stack" style="margin-bottom: 2rem">
      <div>
        <h3>Voices</h3>
        <label for="voices"></label>
        <input
          style="width: 3rem"
          type="number"
          min="1"
          max="8"
          id="voices"
          value="3"
        />
      </div>
      <div>
        <h3>Note range</h3>
        <input
          type="number"
          id="note-max"
          min="3"
          max="36"
          value="24"
          style="width: 3rem"
        />
        <label for="note-max"> semitones </label>
        <label for="note-letter">from</label>
        <select id="note-letter" style="width: 3rem">
          <option value="C">C</option>
          <option value="D">D</option>
          <option value="E">E</option>
          <option value="F">F</option>
          <option value="G">G</option>
          <option value="A" selected>A</option>
          <option value="B">B</option>
        </select>
        <input type="number" min="0" max="8" id="note-number" value="3" />
        <select id="note-modifier">
          <option value="none"></option>
          <option value="flat">♭</option>
          <option value="sharp">♯</option>
        </select>
      </div>
      <div>
        <h3>Chord generation</h3>

        <div class="group">
          <label for="tries"
            >Chord generation attempts =
            <span id="tries-current"></span>
          </label>
          <input type="range" min="1" max="100" id="tries" value="30" />
          <span
            class="hint"
            title="More attempts = higher probability to find consonant chords"
            >?</span
          >
        </div>
        <div class="group">
          <label for="max-beating"
            >Beating frequency tolerance =
            <span id="max-beating-current"></span>
            Hz</label
          >
          <input
            type="range"
            min="0.1"
            max="10"
            step="0.1"
            id="max-beating"
            value="3"
          />
          <span
            class="hint"
            title="Spectral lines closer than that will be considered a single line"
            >?</span
          >
        </div>
      </div>
      <div>
        <h3>Voicing</h3>
        <div class="group">
          <label for="duration"
            >Chord duration =
            <span id="duration-current"></span>
            sec</label
          >
          <input
            type="range"
            min="1"
            max="10"
            step="0.1"
            id="duration"
            value="5"
          />
        </div>
        <div class="group">
          <label for="loudness-rolloff-power"
            >Voice loudness roll-off ~ frequency
            <sup id="loudness-rolloff-power-current"></sup>
          </label>
          <input
            type="range"
            min="-2"
            max="0"
            step="0.1"
            value="-1"
            id="loudness-rolloff-power"
          />
          <span
            class="hint"
            title="Higher frequencies will sound quieter according to the power law, emulating natural instruments"
            >?</span
          >
        </div>
      </div>
    </div>
    <div class="group">
      <button id="play" style="padding: 0.5rem 1rem">Play once</button>
      <div class="group">
        <input type="checkbox" id="autoplay" />
        <label for="autoplay">Autoplay</label>
      </div>
    </div>
    <script>
      // controls

      for (const [sliderId, outputId] of [
        ["tries", "tries-current"],
        ["max-beating", "max-beating-current"],
        ["duration", "duration-current"],
        ["loudness-rolloff-power", "loudness-rolloff-power-current"],
      ]) {
        const slider = document.getElementById(sliderId);
        const output = document.getElementById(outputId);
        output.innerHTML = slider.value;
        slider.oninput = (e) => {
          output.innerHTML = e.target.value;
        };
      }

      const NOTE_LETTERS = ["C", "D", "E", "F", "G", "A", "B"];
      function parseBaseFreq(letter, octave, modifier) {
        let refStep = 6; // A4 = 440 Hz
        let refOctave = 4;
        let refFreq = 440;

        let step =
          NOTE_LETTERS.indexOf(letter) +
          1 +
          (modifier == "flat" ? -1 : modifier == "sharp" ? 1 : 0);
        return (
          refFreq * Math.pow(2, octave - refOctave + (step - refStep) / 12)
        );
      }

      function currentConfig() {
        const noteLetter = document.getElementById("note-letter").value;
        const noteNumber = document.getElementById("note-number").value;
        const noteModifier = document.getElementById("note-modifier").value;
        const baseFreq = parseBaseFreq(noteLetter, noteNumber, noteModifier);
        console.log(noteLetter, noteNumber, noteModifier, "->", baseFreq, "Hz");
        return {
          nVoices: parseInt(document.getElementById("voices").value),
          noteMax: parseInt(document.getElementById("note-max").value),
          freqMin: baseFreq,
          maxBeatingFreq: parseFloat(
            document.getElementById("max-beating").value
          ),
          tries: parseFloat(document.getElementById("tries").value),
          duration: parseFloat(document.getElementById("duration").value),
          loudnessRollOffPower: parseFloat(
            document.getElementById("loudness-rolloff-power").value
          ),
        };
      }

      const playButton = document.getElementById("play");
      const autoplayToggle = document.getElementById("autoplay");

      function isAutoplay() {
        return autoplayToggle.checked;
      }

      const noteMin = 0;

      function noteFreq(note, config) {
        return config.freqMin * Math.pow(2, (note - noteMin) / 12);
      }

      function generateRandomChord(config) {
        const range = config.noteMax - noteMin + 1;
        let res = [];
        for (let i = 0; i < config.nVoices; i++) {
          for (let try_ = 0; try_ < 10; try_++) {
            const note = noteMin + Math.floor(Math.random() * range);
            if (!res.includes(note)) {
              res.push(note);
              break;
            }
          }
        }
        res.sort((a, b) => a - b);
        return res;
      }

      function chordSpectralLines(chord, config) {
        const MAX_HARMONIC = 16;
        const freqMin = noteFreq(chord[0], config);
        const freqMax =
          noteFreq(chord[chord.length - 1], config) * MAX_HARMONIC;
        // adding all possible spectral lines
        let lines = [];
        for (const note of chord) {
          let baseFreq = noteFreq(note, config);
          for (let mult = 1; mult <= MAX_HARMONIC; mult++) {
            // TODO: weighting
            lines.push(mult * baseFreq);
          }
        }
        lines.sort((a, b) => a - b);
        // iteratively collapsing close enough lines
        let newLines = [];
        for (let try_ = 0; try_ < 100; try_ += 1) {
          newLines = [];
          for (var i = 0; i < lines.length; i += 2) {
            let l1 = lines[i];
            let l2 = i < lines.length - 1 ? lines[i + 1] : l1;
            if (0.5 * (l2 - l1) < config.maxBeatingFreq) {
              newLines.push(0.5 * (l1 + l2));
            } else {
              newLines.push(l1, l2);
            }
          }
          if (newLines.length === lines.length) {
            break;
          }
          lines = newLines;
        }
        return {
          lines: newLines,
          lineDensity: newLines.length / Math.log2(freqMax / freqMin),
        };
      }

      function generateChord(config, forbiddenChord) {
        let bestChord = null;
        let bestLines = null;
        let bestChordLinesDensity = 1e10;
        let try_ = 0;
        while (try_ < config.tries) {
          let chord = generateRandomChord(config);
          if (
            forbiddenChord &&
            forbiddenChord.every((note, idx) => note === chord[idx])
          ) {
            continue;
          }
          let { lines, lineDensity } = chordSpectralLines(chord, config);
          if (lineDensity < bestChordLinesDensity) {
            bestChordLinesDensity = lineDensity;
            bestLines = lines;
            bestChord = chord;
          }
          try_ += 1;
        }
        return {
          chord: bestChord,
          lines: bestLines,
          lineDensity: bestChordLinesDensity,
        };
      }

      // audio stuff

      const audioContext = new (window.AudioContext ||
        window.webkitAudioContext)();
      let prevChord = null;

      function playChord() {
        const config = currentConfig();
        console.log(config);

        let { chord, lineDensity, lines } = generateChord(config, prevChord);
        prevChord = chord;
        console.log(
          "Generated chord:",
          chord,
          "with line density (~ spec lines / octave)",
          lineDensity
        );

        let oscillators = [];
        for (const note of chord) {
          const oscillator = audioContext.createOscillator();
          oscillator.type = "triangle";

          const frequency = noteFreq(note, config);
          oscillator.frequency.setValueAtTime(
            frequency,
            audioContext.currentTime
          );

          const baseGain = 0.5;
          const chordGain = baseGain / config.nVoices;
          const gain =
            chordGain *
            Math.min(1, Math.pow(frequency / 220, config.loudnessRollOffPower));
          const attackFraction = 0.1;
          const attack =
            config.duration * (attackFraction * 0.5 * (1 + Math.random()));
          const decayFraction = 0.5;
          const decay =
            config.duration * (decayFraction * 0.5 * (1 + Math.random()));
          const gainNode = audioContext.createGain();
          gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(
            gain,
            audioContext.currentTime + attack
          );
          gainNode.gain.linearRampToValueAtTime(
            gain * 0.6,
            audioContext.currentTime + config.duration - decay
          );
          gainNode.gain.linearRampToValueAtTime(
            0,
            audioContext.currentTime + config.duration
          );
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillators.push(oscillator);
        }

        for (const osc of oscillators) {
          osc.start(audioContext.currentTime);
          osc.stop(audioContext.currentTime + config.duration * 1.1);
        }

        if (isAutoplay()) {
          setTimeout(playChord, (config.duration - 1) * 1000);
        }
      }

      playButton.onclick = () => {
        if (!isAutoplay()) {
          playChord();
        }
      };
      autoplayToggle.onchange = (e) => {
        if (e.target.checked) playChord();
      };
    </script>
  </body>
  <style>
    div.stack {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    div.group {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 1rem;
    }
    h3 {
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
    }
    span.hint {
      padding: 0.3rem;
      cursor: help;
      font-size: small;
    }
  </style>
</html>
